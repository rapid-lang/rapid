

# Rapid Compiler

## Tools

(these can be changed if there is a compelling reason, not "there's one function I need")

We are using Ocaml 4.01 because it is a modern version and is the default for homebrew.

We'll be using the OCaml standard library.
This is not "Core" and not "Batteries" so be careful while googling.
[The OCaml website](https://ocaml.org/learn/) is the best resource for module documentation, but using Merlin's suggestions is usally just as good.





## Coding Guidelines

- Avoid all unnecessary parentheses
- 4 spaces for indentation
- Only `Open` a module if a large number of types/functions will be used
  - `Open` adds all types and functions to the namespace
  - This is undesirable when we have similarly named types like `expr` and `sexpr`
- Functions should rarely exceed 40 lines




## Flow of the Compiler

Code is tokenized and parsed by the scanner.
The scanner returns a `program`, a set of statements and function declarations made up of types declared in the AST (`ast.mli`).
This AST is then semantically checked.
The process starts by transforming it into a SAST (`sast.mli`), this transformation catches basic type errors.
A subsequent scan and write of the SAST performs all other semantic checks to guarantee that the passed program is correct (rewrites expressions to be typed, adds type annotations to variables, etc).
Any SAST approved by the semantic checker (`semantic_check.ml`) should always generate valid code using `generate.ml`.






## Testing

```bash
make test
```

NOTE: all `fail` tests should be brief as they should only cover one small aspect that induces failure.
If you have 3 invalid lines in a test file, we can only validate that the first one is broken.
You should have a test for every type of invalid parsing or error that the semantic checker can catch.
This is how we can catch any regressions while refactoring.


### AST / Scanner

Parsing and AST features are tested by adding `.rapid` files to `tests/parsing/`.
Files will be tested to see that the parser accepts them.
If you wish to check that a file will be rejected by the parser, start the filename with `fail_`.
All files will be tested by running the script, `parser_tests.sh`.


### SAST / Semantic Checking

SAST and semantic checking features are tested by adding `.rapid` files to `tests/sast/` that should pass the parser.
Files will be tested to be semantically correct.
If you wish to check that a file will be rejected by the semantic checker, start the filename with `fail_`.
All files will be tested by running the script, `sast_tests.sh`.


### Code Generation

Code generation is tested by compiling `.rapid` files and running the resulting Golang programs.
Add `.rapid` files to `tests/compiler/` and accompany them with a `.output` file for the expected output.
All programs will be tested by running the script, `sast_tests.sh`.








## Debugging

#### Tools

Please install [merlin](http://the-lambda-church.github.io/merlin/), it will make getting used to OCaml much easier ([sublime text plugin](https://github.com/Cynddl/sublime-text-merlin)).

If you need to update the Makfile, follow the comment instructions to regenerate the dependencies between OCaml modules.

You will need Golang installed to run the compiler tests.
If you want to easily mess around with the generated code, copy it into [the playground](http://play.golang.org/) which format it among other things.



#### Parser / Scanner / AST

Make sure to read the output of the tests closely.
If YACC fails to compile the parser, it will fail before reaching the tests, if any tests run, then the parse is building.
When a parsing test fails, the output of YACC is included in the message.
NOTE: The error may not be YACC related, make sure to carefully read the output.

If your error is YACC related, you can generate the referenced table with `yacc -v parser.mly`.
This is necessary to step through the shifting and reducing performed to figure out why the parser is not working as you intended.

If your error is AST related, it should only be because you are missing relevant print methods in `ast_printer.ml`.
If you are unsure that the `ast.mli` file is valid, compile it (`ocalmc -c ast.mli`) to confirm there are no errors in the syntax.



#### SAST / Semantic Checking

Examine the AST being passed and confirm that it is formed as you expect it to be.
Trace through the code and make sure that untyped expressions are being rewritten.
Confirm that there are no lists that should be reversed.







## Files

What each file defines and is used for.


#### scanner.mll

Tokenizes a character stream.

#### parser.mly

Reads in a token stream from `scanner.mll` and builds a AST from the tokens.

#### ast.mli

Defines all types in the abstract syntax tree (AST) that is generated by the parser.

#### ast_printer.ml

Generates a string representation of the AST for debugging purposes.

#### datatypes.mli

Defines basic primitive datatypes that are used in both the AST and SAST.

#### test_parser.ml

Generates a AST from stdin and attempts to print the AST.
This is useful for debugging and is also utilized in the parser tests.

#### sast.mli

This defines all types in the Semantic Abstract Syntax Tree (SAST).

#### sast_printer.ml

Generates a string representation of the SAST for debugging purposes.

#### sast_helper.ml

Defines some utility functions for the semantic checking.
The type table and it's accompanying functions are defined here.

#### semantic_check.ml

Performs semantic checking on untyped SAST.
Any SAST returned by `sast_from_ast` should produce valid code in `generate.ml`.

#### translate.ml

This performs a naive transformation of a AST to a SAST.
It should catch simple type errors but primarily will leave untyped expressions when not sure (i.e. all variable references are left as `SVar`).

#### test_sast.ml

Generates a type checked SAST from stdin and attempts to print the SAST.
This is useful for debugging and is also utilized in the sast tests.

#### generate.ml

Generates a string of Golang code from a type checked SAST.
Should fail if non checked elementes (like `SVar`) are found in the SAST.

#### rapid.ml

The compiler executable.
Rapid code is read in from stdin and generates valid golang code to stdout.
The IO workings will likely be reworked.

